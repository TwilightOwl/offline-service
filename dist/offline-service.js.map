{"version":3,"file":"offline-service.js","sources":["../node_modules/tslib/tslib.es6.js","../src/cache.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export enum RefreshCacheStrategy {\n    RefreshWhenExpired,\n    RefreshAlways,\n    NoStore\n}\n\nexport enum RequestCacheStrategy {\n    CacheOnly,\n    NetworkOnly,\n    CacheFallingBackToNetwork,\n    NetworkFallingBackToCache,\n    CacheThenNetwork\n}\n\nexport enum RequestTypes {\n    DataSendRequest,\n    DataReceiveRequest\n}\n\ninterface RequestInitWithCacheParameters extends RequestInit {\n    refreshCacheStrategy?: RefreshCacheStrategy,\n    requestCacheStrategy?: RequestCacheStrategy,\n    requestType?: RequestTypes\n}\n\nenum CacheStatus {\n    DoesNotExist,\n    Unexpired,\n    Expired,\n}\n\nexport interface ResponseWithCacheInfo extends Response {\n    cached?: boolean,\n    expired?: boolean\n}\n\ntype MergeResponseWithCacheInfo = (response: Response, cacheStatus: CacheStatus | undefined) => ResponseWithCacheInfo;\n\ninterface RequestResult {\n    response: Response,\n    cacheStatus?: CacheStatus\n}\n\ninterface CacheThenNetworkRequestResult {\n    response?: Response,\n    cacheStatus?: CacheStatus\n}\n\ntype RequestFunction = (url: RequestInfo, params?: RequestInit) => Promise<RequestResult>;\n\ntype CacheThenNetworkRequestFunction = (url: RequestInfo, params?: RequestInit) => Promise<CacheThenNetworkRequestResult>;\n\nenum CachingResult {\n    // HasBeenAdded,\n    HasBeenUpdated,\n    NotUpdated\n}\n\ntype CachingFunction = (url: RequestInfo, params: RequestInit | undefined, data: any, cacheStatus?: CacheStatus) => Promise<CachingResult>;\n\nexport interface CacheThenNetworkRequestStrategyResult {\n    cached?: ResponseWithCacheInfo,\n    network: Promise<ResponseWithCacheInfo>\n}\n\ntype CustomRequest = (url: RequestInfo, params: RequestInitWithCacheParameters) => Promise<ResponseWithCacheInfo | CacheThenNetworkRequestStrategyResult>;\n\ntype HttpRequest = (url: RequestInfo, data?: RequestInit) => Promise<Response>;\n\ninterface CachedItem {\n    key: string,\n    data: any, // Response\n    until: number\n}\n\ninterface Storage {\n    //TODO: return result \n    set: (key: string, data: CachedItem) => Promise<boolean>,\n    get: (key: string) => Promise<null | CachedItem>,\n    delete: (key: string) => Promise<boolean>,\n}\n\ntype GetCacheKey = (url: RequestInfo, params?: RequestInit) => string;\n\ninterface Constructor {\n    request: HttpRequest,\n    storage: Storage,\n    getCacheKey: GetCacheKey\n}\n\nexport default class OfflineService {\n    private httpRequest: HttpRequest;\n    private storage: Storage;\n    private getCacheKey: GetCacheKey;\n\n    constructor({ request, storage, getCacheKey }: Constructor) {\n        this.httpRequest = request;\n        this.storage = storage;\n        //TODO: implement key extractor\n        this.getCacheKey = getCacheKey;\n    }\n\n    // ==================== Storage functions ====================\n     \n    private setCacheItem = async (key: string, data: any, ttl = 10000) => {\n        return this.storage.set(key, { key, data, until: Date.now() + ttl });\n    }\n\n    private getCacheItem = async (key: string) => {\n        const cached = await this.storage.get(key);\n        if (cached === null) {\n            return { exist: false }\n        } else {\n            return { \n                exist: true, \n                expired: cached.until < Date.now(), \n                data: cached.data \n            };\n        }\n    }\n\n    // ==================== Request functions ====================\n\n    private networkOnlyRequest: RequestFunction = async (...args) => {\n        return ({ response: await this.httpRequest(...args) }) as RequestResult;\n    }\n    \n    private cacheOnlyRequest: RequestFunction = async (url, params) => {\n        const cacheKey = this.getCacheKey(url, params);\n        const { exist, expired, data } = await this.getCacheItem(cacheKey);\n        if (exist) {\n            return { response: data, cacheStatus: expired ? CacheStatus.Expired : CacheStatus.Unexpired }\n        } else {\n            //TODO: think about format of this error\n            throw \"The requested data doesn't exist in the cache\"\n        }\n    };\n    \n    private networkFallingBackToCacheRequest: RequestFunction = async (url, params) => {\n        try {\n            const { response } = await this.networkOnlyRequest(url, params);\n            if (response.ok) {\n                return { response }\n            } else {\n                throw response\n            }\n        } catch (networkError) {\n            try {\n                // without \"await\" catch block will not handle exception!\n                return await this.cacheOnlyRequest(url, params);\n            } catch (cacheError) {\n                //TODO: think about format of this error, maybe provide networkError somehow...\n                throw \"The network request has been failed but cached data doesn't exist\"\n            }\n        }\n    };\n    \n    private cacheFallingBackToNetworkRequest: RequestFunction = async (url, params) => {\n        try {\n            const { response, cacheStatus } = await this.cacheOnlyRequest(url, params);\n            if (cacheStatus === CacheStatus.Unexpired) {\n                return { response, cacheStatus }\n            } else {\n                throw \"The cache data is expired\"\n            }\n        } catch (cacheError) {\n            try {\n                return await this.networkOnlyRequest(url, params);\n            } catch (networkError) {\n                //TODO: think about format of this error, maybe provide networkError somehow...\n                throw \"The cache doesn't exist or expired but network request has been faild\"\n            }\n        }\n    }\n    \n    // It's just a first part of algorythm, in the \"request\" method a second part will be invoked \n    //   by recursive call of \"request\" with NetworkOnly strategy\n    private cacheThenNetworkRequest: CacheThenNetworkRequestFunction = async (url, params) => {\n        try {\n            return await this.cacheOnlyRequest(url, params)\n        } catch (error) {\n            return { cacheStatus: CacheStatus.DoesNotExist }\n        }\n    }\n\n    // ==================== Caching functions ====================\n\n    private refreshAlwaysCaching: CachingFunction = async (url, params, data, cacheStatus) => {\n        if (cacheStatus !== undefined) {\n            // the data has been received from cache, we sholudn't update cache data\n            return CachingResult.NotUpdated\n        }\n        const cacheKey = this.getCacheKey(url, params);\n        try {\n            await this.setCacheItem(cacheKey, data);\n            return CachingResult.HasBeenUpdated\n        } catch (error) {\n            //TODO: think\n            throw error\n        }\n    };\n    \n    private refreshWhenExpiredCaching: CachingFunction = async (url, params, data, cacheStatus) => {\n        if (cacheStatus !== undefined) {\n            // the data has been received from cache, we sholudn't update cache data\n            return CachingResult.NotUpdated\n        }\n    \n        const cacheKey = this.getCacheKey(url, params);\n        const { exist, expired, ...rest } = await this.getCacheItem(cacheKey);\n        if (exist && !expired) {\n            return CachingResult.NotUpdated\n        } else {\n            await this.setCacheItem(cacheKey, data);\n            return CachingResult.HasBeenUpdated\n        }\n    \n    };\n\n    private mergeResponseWithCachedInfo: MergeResponseWithCacheInfo = (response: Response, cacheStatus: CacheStatus | undefined) => {\n        return cacheStatus === undefined\n            ? response \n            : { ...response, cached: true, expired: cacheStatus === CacheStatus.Expired }\n    }\n\n    public request = async (url: RequestInfo, params: RequestInitWithCacheParameters) => {\n        const { \n            requestType = RequestTypes.DataReceiveRequest, \n            // requestCacheStrategy = RequestCacheStrategy.CacheFallingBackToNetwork, \n            // refreshCacheStrategy = RefreshCacheStrategy.RefreshAlways,\n            ...rest\n        } = params;\n        return requestType === RequestTypes.DataSendRequest ? await this.sendRequest(url, rest) : await this.receiveRequest(url, rest)\n    }\n\n    private sendRequest: CustomRequest = async (url: RequestInfo, params: RequestInitWithCacheParameters) => {\n        const cacheKey = this.getCacheKey(url, params)\n        await this.saveToQueue({ url, params, cacheKey, entity: (params || {}).entity || undefined });\n\n    }\n\n    private receiveRequest: CustomRequest = async (url: RequestInfo, params: RequestInitWithCacheParameters) => {\n        const { \n            refreshCacheStrategy = RefreshCacheStrategy.RefreshAlways,\n            requestCacheStrategy = RequestCacheStrategy.CacheFallingBackToNetwork, \n            // requestType = RequestTypes.DataReceiveRequest, \n            ...restParams \n        } = params;\n        //if (requestType === RequestTypes.DataReceiveRequest) {\n            try {\n                const { response, cacheStatus } = await ({\n                    [RequestCacheStrategy.NetworkOnly]: this.networkOnlyRequest,\n                    [RequestCacheStrategy.CacheOnly]: this.cacheOnlyRequest,\n                    [RequestCacheStrategy.NetworkFallingBackToCache]: this.networkFallingBackToCacheRequest,\n                    [RequestCacheStrategy.CacheFallingBackToNetwork]: this.cacheFallingBackToNetworkRequest,\n                    [RequestCacheStrategy.CacheThenNetwork]: this.cacheThenNetworkRequest,\n                }[requestCacheStrategy] || (() => { throw 'Unknown request cache strategy' }))(url, restParams);\n    \n                if (requestCacheStrategy === RequestCacheStrategy.CacheThenNetwork) {\n                    return {\n                        ...response ? { cached: this.mergeResponseWithCachedInfo(response, cacheStatus) } : {},\n                        network: this.request(url, { ...params, requestCacheStrategy: RequestCacheStrategy.NetworkOnly }) as Promise<ResponseWithCacheInfo>\n                    }\n                }\n    \n                if (response!.ok) {\n                    try {\n                        const cacheResult = await ({\n                            [RefreshCacheStrategy.NoStore]: () => {},\n                            [RefreshCacheStrategy.RefreshAlways]: this.refreshAlwaysCaching,\n                            [RefreshCacheStrategy.RefreshWhenExpired]: this.refreshWhenExpiredCaching,\n                        }[refreshCacheStrategy] || (() => { throw 'Unknown refresh cache strategy' }))(url, restParams, response, cacheStatus);\n                        \n                        return this.mergeResponseWithCachedInfo(response!, cacheStatus);\n    \n                    } catch (error) {\n                        //TODO: provide error object\n                        throw 'Caching has been failed'\n                    }\n                } else {\n                    //TODO: to think about this case\n                    throw response\n                }\n            } catch (error) {\n                throw error;\n            }\n    \n        //} else if (requestType === RequestTypes.DataSendRequest) {\n            // TODO: big work!!!!!!!\n\n            /**\n             * 1. записать в сторадж (если очередь на отправку пустая, то в сторадж пишем только если пришла ошибка отправки нашего запроса,\n             *      если очередь не пустая, не важно нету сейчас соединения или запросы из очереди прямо сейчас отправляются успешно, пишем\n             *      сначала в сторадж, а потом добавляем в очередь запрос. т.к. вполне возмоно при наличии сети, что просто до запроса не дойдет\n             *      очередь потому что пользователь вырубил приложение)\n             *  - hash, \n             *  - response \n             *  - requestId (по сути только url, параметризуется можно ли слать еще запросы на этот url (но с другим хэшэм) когда уже есть \n             *      неотправленные запросы\n             *  - entity возможно понадобится для чтения сущностей\n             *  - автоматизировать подсовывание в гет запросы сущностей, не отправленных в пост запросах нельзя т.к.:\n             *      - не известно в каком формате должны придти сохраненные сущности ведь они еще не сохранены\n             *      - связь между гет запрами и неотправленными сущностями может быть \"много ко многим\" тогда не обойтись одим только entity и \n             *          вообще сервис не должен знать о смысловой нагрузке данных и бизнес логике и потому не сможет подсовывать в гет запросы \n             *          какие-то сохраненные данные, это дело бизнес логики, по entity БЛ сможет получить неотправленные данные и как-то их \n             *          обработав подсунуть в гет запрос\n             * \n             * 2. если есть данные для отправки, то уже должен быть запущен \"параллельный\" процесс по отправке данных, но при добавлении новых \n             *      данных, нужно не ждать следующую итерацию отправки, а сразу попробовать запустить\n             *  - избегать утечки\n             *  - когда данных для отправки нет, то и в фоне не должно выполняться никаких проверок, процесс запускается при сохраненнии \n             *      данных и продолжается пока есть неотправленные данные\n             *  - нужно сохранять последовательность с которой пользователь пытался отправить данные!!!\n             *  - у очереди должен быть текущий статус - есть сеть или нету, по результату последнего на данный момент выполненного запроса,\n             *      если статус НЕТ СЕТИ новый запрос при попадании в очередь резолвится сразу с ошибкой сети и вторым промисом (описано дальше) \n             *      если статус ЕСТЬ СЕТЬ то новый добавленный в очередь запрос ожидает своей очереди на отправку, т.е. первый промис в \n             *      состоянии ожидания. для внешнего вызываемого этот запрос приложения будет как-будто запрос просто долго выполняется\n             * \n             * 3. Публичная функция отправки (запись в сторадж -> сетевой запрос) должна быть промисом, который при нормальной работе должен \n             *      зарезолвиться (реджект если в сторадж не удалось записать, т.е. какие-то не предвиденные технические ошибки) и вернуть:\n             *      - (1) результат запроса (в случае рабочей сети, при этом сам результат может быть и плохим (допустимые ошибки бизнес логики\n             *          с сервера), не рабочую сеть надо определять по эксепшену fetch'а или ok=false, надо в доке уточнить) Как обрабатывать\n             *          5хх ошибки? сохранять ли порядок запросов если застопорились на 5хх и новые запросы даже не будут пытаться отправляться\n             *          т.к. застряли на каком-то запросе с ответом 5хх, что это? ошибка безнес логики или ошибка сервера?\n             *      - (2) другой промис, который зарезолвится, когда эти данные все таки отправятся через фоновый процесс, этот промис должен вернуть \n             *          результат как в первом случае. ( * * * После перезапуска приложения неотправленные запросы десериализуются из стораджа, \n             *          но промисов уже нет, колбэки тоже не сериализовать, можно сделать эмиттер, а после перезапуска приложения, кому надо тот \n             *          подпишется на события отправления данных, но это слишком заморочено, и не понятно пока как в коде это сделать лаконично, \n             *          и вообще нужно ли после перезапуска приложения отслеживать отправку ранее не отправленных данных??? * * * )\n             *          В этом случае (2) мы знаем что такой результат говорит о том, что данные сохранились в сторадж\n             *          и бизнес логика должна как-то узнать об этом, т.к. могут быть какие-то данные в интерфейсе полученные гет запросом, но к \n             *          ним надо подмешать эти сохраненные пока еще не отправленные данные. А при завершении второго промиса, мы понимаем что данные\n             *          успешно отправились на сервер (или не успешно, в случае ошибок с сервера, которые допускает логика работы приложения) и \n             *          удалились из стораджа -> надо опять проинформировать бизнес логику о том что теперь этих данных нет в сторадже и бери их\n             *          с сервера нормальным гет запросом (теперь если сети нету, то гет запрос может сфэйлиться и данные возьмутся из кэша, но \n             *          в кэше данные с прошлого гет запроса и данных которые мы отправили пост запросов там еще нету, можно пренебречь этой\n             *          ситуацией как редкой, \n             *          // --- этот блок сильно замороченный и для обычной работы он не нужен, только если сильно упороться --- //\n             *          но можно оставлять в сторадже данные, пометив их как отправленные, и они будут использоваться только лишь \n             *          для подмешивания в устаревшие данные из кэша. когда гет запрос все таки выполнится, кэш обновится, в не уже будут эти \n             *          добавленные данные, т.к. они теперь с бэка придут, и в стордже их можно почистить. тогда надо придумывать механизм \n             *          подсчета ссылок, т.к. эти отправленные но оставшиеся данные в сторадже могут быть использованы разными гет запросами)\n             *          // ---------------------------------------------------------------------------------------------------- //\n             *          Информировать БЛ о данных сохраненных и удаленных в стордже нужно через механизм подписок или колбэков, но потом эти\n             *          обработчики уже обновляют mobx сторы бизнес логики, чтобы сам сервис не был завязан на mobx. Или когда вернулся результат (2)\n             *          это и значит что в сторадже появилист данные, а когда в будущем зарезолвится возвращенный промис, это значит данные отправились.\n             *          Эти данные из стораджа могут понадобиться вообще в другом месте а не в месте вызова публичного метода отправки, поэтому\n             *          их надо взяв из стораджа положить в observable, а любые другие публичные данные любых сторов, которые в результат гет запроса \n             *          подмешивают стордж данные, должны быть computed и завязаны на observable пришедшие с гет запроса и observable пришедший со\n             *          стораджа. \n             *  \n             *          Пример показывающий как данные полученные гет запросом в AnyBusinessMobxStore могут быть совмещены с данными которые были\n             *              неуспешно отправлены пост запросом из стора AnyOtherBusinessMobxStore. TempStorageMobxStore - стор для хранения \n             *              observable копий данных из стораджа (данных находящихся в очереди на отправку)\n             *          \n             *        AnyBusinessMobxStore:\n             *          receiveRequest  ->  observable items  ->  computed dataForUI = this.items + TempStorageMobxStore.savedButNotSentData[entity]\n             *                                                                                                                   ^\n             *        TempStorageMobxStore:                                                                                       \\\n             *          observable savedButNotSentData = { [entity]: ... , [entity]: ... }                                         \\ computed reaction\n             *                                                                                                                      \\    \n             *        AnyOtherBusinessMobxStore:                                                                                     \\      \n             *          sendRequest(entity)  ->  (bad network)  ->  TempStorageMobxStore.actionRetrieveFromStorageByEntity(entity): savedButNotSentData[entity] = savedData\n             *                                                  \\\n             *                                                   \\промис отвечающий за реальную отправку данных на сервер резолвится   \n             *                                                    \\\n             *                                                  чистим данные в сторе, т.к. этих данных теперь нету в сторадже - они успешно (или не успешно, но это норм, если бэку данные не понравились) отправлены на сервер\n             *                                                  TempStorageMobxStore.actionClearDataByEntity(entity): delete savedButNotSentData[entity]\n             *  \n             *           sendRequest(entity)  ->  (good network) ->  как-то вручную в бизнес логике запускать AnyBusinessMobxStore.receiveRequest.\n             *              Или предумать вообще систему отдельную от этой, которая будет хранить зависимости данных между сторами, и запускать\n             *              получение данных с сервера автоматически, через реакции. Либо как-то инвалидировать кэш.\n             *  \n             *  Пример попадания запросов в очередь:\n             *      - запрос пришел. очередь пуста?\n             *          ? пытаемся отправить. результат переводим в бинарный: есть сеть (2хх, 4хх,  5хх???) или нет сети (5хх ???, catch)\n             *            если во время выполнения запроса прилетает новый запрос, пишем данные нового запроса в сторадж и помещаем новый запрос \n             *            в очередь. при инициализации очереди, у нее статус в сети, поэтому новый запрос просто будет ждать своей очереди.\n             *            текущий запрос выполнился с результатом ЕСТЬ СЕТЬ?\n             *              ? резолвим основной промис с результатом запроса, выкидываем из очереди запрос, т.к. он уже успешно выполнился,\n             *                  статус очереди ставим ЕСТЬ СЕТЬ, переходим к выполнению следующего запроса в очереди (если есть)\n             *              : пишем данные запроса в сторадж, резолвим основной промис с результатом НЕТ СЕТИ и со вторым промисом, ожидающим\n             *                  успешного завершения запроса. сам запрос остается в очереди, но с ожидающим вторым промисом. для всех запросов\n             *                  в очереди (которые еще не зарезолвили основной промис) резолвим по аналогии с текущим запросом, и так же оставляем\n             *                  их в очереди с промисом ожидающим корректного завершения запроса.\n             *          : пишем данные нового запроса в сторадж и помещаем новый запрос в очередь. текущее состояние очереди == ЕСТЬ СЕТЬ?\n             *              ? до этого запроса очередь сама дойдет.\n             *              : резолвим основной промис с результатом НЕТ СЕТИ и со вторым промисом, ожидающим успешного завершения запроса. запрос\n             *                  остается в очереди.\n             *      - если очередь не пустая в статусе НЕТ СЕТИ, то периодически запускается попытка отправки заново первого запроса в сети.\n             *      - если в непустую очередь со статусом НЕТ СЕТИ попадает новый запрос, то не дожидаясь следующего автоматического запуска\n             *          попытки отправки первого запроса в очереди, сами запускаем ее, при этом таск для автоматической отправки удаляется,\n             *          но при неуспешной отправке опять запускается новый таск (таск - запуск попытки отправки через setInterval, таск \"живет\n             *          в памяти\" переодически запуская попытку отправки, запуская отправку вручную, мы чистим setInterval, и при отсутствии сети\n             *          создаем новый таск - новый setInterval) при первой же успешной отправке запроса, текущий таск должен чиститься.\n             *      - для перестраховки, чтобы таск не запустил тот же запрос или паралельно следующий, нужно в свойствах очереди также хранить\n             *          флаг processing, говорящий о том что в данный момент выполняются запросы в очереди. при успешном завершении запроса и\n             *          переходе к следующему запросу, processing остается true. если автоматический таск при попытке запустить отправку запроса\n             *          натыкается на состояние processing == true, значит что-то пошло не так и остался не удаленный таск, поэтому: \n             *          не запускаем попытку отправки запроса (уже запущено), таск удаляем, новый таск создастся если очередной запрос опять \n             *          сфэйлится с ошибкой отсутствия сети\n             */\n\n            throw 'TODO'\n        // } else {\n        //     throw 'Unknown request type';\n        // }\n    }\n}"],"names":[],"mappings":"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"}