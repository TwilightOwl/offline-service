export { default as default } from './sender';
/**
             * 1. записать в сторадж (если очередь на отправку пустая, то в сторадж пишем только если пришла ошибка отправки нашего запроса,
             *      если очередь не пустая, не важно нету сейчас соединения или запросы из очереди прямо сейчас отправляются успешно, пишем
             *      сначала в сторадж, а потом добавляем в очередь запрос. т.к. вполне возмоно при наличии сети, что просто до запроса не дойдет
             *      очередь потому что пользователь вырубил приложение)
             *  - hash,
             *  - request data
             *  - requestId (по сути только url, параметризуется можно ли слать еще запросы на этот url (но с другим хэшэм) когда уже есть
             *      неотправленные запросы
             *  - entity возможно понадобится для чтения сущностей (ЭТО В СТОРАДЖЕ НЕ НУЖНО, это делается на уровне сторов)
             *  - автоматизировать подсовывание в гет запросы сущностей, не отправленных в пост запросах нельзя т.к.:
             *      - не известно в каком формате должны придти сохраненные сущности ведь они еще не сохранены
             *      - связь между гет запрами и неотправленными сущностями может быть "много ко многим" тогда не обойтись одим только entity и
             *          вообще сервис не должен знать о смысловой нагрузке данных и бизнес логике и потому не сможет подсовывать в гет запросы
             *          какие-то сохраненные данные, это дело бизнес логики, по entity БЛ сможет получить неотправленные данные и как-то их
             *          обработав подсунуть в гет запрос
             *
             * 2. если есть данные для отправки, то уже должен быть запущен "параллельный" процесс по отправке данных, но при добавлении новых
             *      данных, нужно не ждать следующую итерацию отправки, а сразу попробовать запустить
             *  - избегать утечки
             *  - когда данных для отправки нет, то и в фоне не должно выполняться никаких проверок, процесс запускается при сохраненнии
             *      данных и продолжается пока есть неотправленные данные
             *  - нужно сохранять последовательность с которой пользователь пытался отправить данные!!!
             *  - у очереди должен быть текущий статус - есть сеть или нету, по результату последнего на данный момент выполненного запроса,
             *      если статус НЕТ СЕТИ новый запрос при попадании в очередь резолвится сразу с ошибкой сети и вторым промисом (описано дальше)
             *      если статус ЕСТЬ СЕТЬ то новый добавленный в очередь запрос ожидает своей очереди на отправку, т.е. первый промис в
             *      состоянии ожидания. для внешнего вызываемого этот запрос приложения будет как-будто запрос просто долго выполняется
             *
             * 3. Публичная функция отправки (запись в сторадж -> сетевой запрос) должна быть промисом, который при нормальной работе должен
             *      зарезолвиться (реджект если в сторадж не удалось записать, т.е. какие-то не предвиденные технические ошибки) и вернуть:
             *      - (1) результат запроса (в случае рабочей сети, при этом сам результат может быть и плохим (допустимые ошибки бизнес логики
             *          с сервера), не рабочую сеть надо определять по эксепшену fetch'а или ok=false, надо в доке уточнить) Как обрабатывать
             *          5хх ошибки? сохранять ли порядок запросов если застопорились на 5хх и новые запросы даже не будут пытаться отправляться
             *          т.к. застряли на каком-то запросе с ответом 5хх, что это? ошибка безнес логики или ошибка сервера?
             *      - (2) другой промис, который зарезолвится, когда эти данные все таки отправятся через фоновый процесс, этот промис должен вернуть
             *          результат как в первом случае. ( * * * После перезапуска приложения неотправленные запросы десериализуются из стораджа,
             *          но промисов уже нет, колбэки тоже не сериализовать, можно сделать эмиттер, а после перезапуска приложения, кому надо тот
             *          подпишется на события отправления данных, но это слишком заморочено, и не понятно пока как в коде это сделать лаконично,
             *          и вообще нужно ли после перезапуска приложения отслеживать отправку ранее не отправленных данных??? * * * )
             *          В этом случае (2) мы знаем что такой результат говорит о том, что данные сохранились в сторадж
             *          и бизнес логика должна как-то узнать об этом, т.к. могут быть какие-то данные в интерфейсе полученные гет запросом, но к
             *          ним надо подмешать эти сохраненные пока еще не отправленные данные. А при завершении второго промиса, мы понимаем что данные
             *          успешно отправились на сервер (или не успешно, в случае ошибок с сервера, которые допускает логика работы приложения) и
             *          удалились из стораджа -> надо опять проинформировать бизнес логику о том что теперь этих данных нет в сторадже и бери их
             *          с сервера нормальным гет запросом (теперь если сети нету, то гет запрос может сфэйлиться и данные возьмутся из кэша, но
             *          в кэше данные с прошлого гет запроса и данных которые мы отправили пост запросов там еще нету, можно пренебречь этой
             *          ситуацией как редкой,
             *          // --- этот блок сильно замороченный и для обычной работы он не нужен, только если сильно упороться --- //
             *          но можно оставлять в сторадже данные, пометив их как отправленные, и они будут использоваться только лишь
             *          для подмешивания в устаревшие данные из кэша. когда гет запрос все таки выполнится, кэш обновится, в не уже будут эти
             *          добавленные данные, т.к. они теперь с бэка придут, и в стордже их можно почистить. тогда надо придумывать механизм
             *          подсчета ссылок, т.к. эти отправленные но оставшиеся данные в сторадже могут быть использованы разными гет запросами)
             *          // ---------------------------------------------------------------------------------------------------- //
             *          Информировать БЛ о данных сохраненных и удаленных в стордже нужно через механизм подписок или колбэков, но потом эти
             *          обработчики уже обновляют mobx сторы бизнес логики, чтобы сам сервис не был завязан на mobx. Или когда вернулся результат (2)
             *          это и значит что в сторадже появилист данные, а когда в будущем зарезолвится возвращенный промис, это значит данные отправились.
             *          Эти данные из стораджа могут понадобиться вообще в другом месте а не в месте вызова публичного метода отправки, поэтому
             *          их надо взяв из стораджа положить в observable, а любые другие публичные данные любых сторов, которые в результат гет запроса
             *          подмешивают стордж данные, должны быть computed и завязаны на observable пришедшие с гет запроса и observable пришедший со
             *          стораджа.
             *
             *          Пример показывающий как данные полученные гет запросом в AnyBusinessMobxStore могут быть совмещены с данными которые были
             *              неуспешно отправлены пост запросом из стора AnyOtherBusinessMobxStore. TempStorageMobxStore - стор для хранения
             *              observable копий данных из стораджа (данных находящихся в очереди на отправку)
             *
             *        AnyBusinessMobxStore:
             *          receiveRequest  ->  observable items  ->  computed dataForUI = this.items + TempStorageMobxStore.savedButNotSentData[entity]
             *                                                                                                                   ^
             *        TempStorageMobxStore:                                                                                       \
             *          observable savedButNotSentData = { [entity]: ... , [entity]: ... }                                         \ computed reaction
             *                                                                                                                      \
             *        AnyOtherBusinessMobxStore:                                                                                     \
             *          sendRequest(entity)  ->  (bad network)  ->  TempStorageMobxStore.actionRetrieveFromStorageByEntity(entity): savedButNotSentData[entity] = savedData
             *                                                  \
             *                                                   \промис отвечающий за реальную отправку данных на сервер резолвится
             *                                                    \
             *                                                  чистим данные в сторе, т.к. этих данных теперь нету в сторадже - они успешно (или не успешно, но это норм, если бэку данные не понравились) отправлены на сервер
             *                                                  TempStorageMobxStore.actionClearDataByEntity(entity): delete savedButNotSentData[entity]
             *
             *           sendRequest(entity)  ->  (good network) ->  как-то вручную в бизнес логике запускать AnyBusinessMobxStore.receiveRequest.
             *              Или предумать вообще систему отдельную от этой, которая будет хранить зависимости данных между сторами, и запускать
             *              получение данных с сервера автоматически, через реакции. Либо как-то инвалидировать кэш.
             *
             *  Пример попадания запросов в очередь:
             *      - запрос пришел. очередь пуста?
             *          ? пытаемся отправить. результат переводим в бинарный: есть сеть (2хх, 4хх,  5хх???) или нет сети (5хх ???, catch)
             *            если во время выполнения запроса прилетает новый запрос, пишем данные нового запроса в сторадж и помещаем новый запрос
             *            в очередь. при инициализации очереди, у нее статус в сети, поэтому новый запрос просто будет ждать своей очереди.
             *            текущий запрос выполнился с результатом ЕСТЬ СЕТЬ?
             *              ? резолвим основной промис с результатом запроса, выкидываем из очереди запрос, т.к. он уже успешно выполнился,
             *                  статус очереди ставим ЕСТЬ СЕТЬ, переходим к выполнению следующего запроса в очереди (если есть)
             *              : пишем данные запроса в сторадж, резолвим основной промис с результатом НЕТ СЕТИ и со вторым промисом, ожидающим
             *                  успешного завершения запроса. сам запрос остается в очереди, но с ожидающим вторым промисом. для всех запросов
             *                  в очереди (которые еще не зарезолвили основной промис) резолвим по аналогии с текущим запросом, и так же оставляем
             *                  их в очереди с промисом ожидающим корректного завершения запроса.
             *          : пишем данные нового запроса в сторадж и помещаем новый запрос в очередь. текущее состояние очереди == ЕСТЬ СЕТЬ?
             *              ? до этого запроса очередь сама дойдет.
             *              : резолвим основной промис с результатом НЕТ СЕТИ и со вторым промисом, ожидающим успешного завершения запроса. запрос
             *                  остается в очереди.
             *      - если очередь не пустая в статусе НЕТ СЕТИ, то периодически запускается попытка отправки заново первого запроса в сети.
             *      - если в непустую очередь со статусом НЕТ СЕТИ попадает новый запрос, то не дожидаясь следующего автоматического запуска
             *          попытки отправки первого запроса в очереди, сами запускаем ее, при этом таск для автоматической отправки удаляется,
             *          но при неуспешной отправке опять запускается новый таск (таск - запуск попытки отправки через setInterval, таск "живет
             *          в памяти" переодически запуская попытку отправки, запуская отправку вручную, мы чистим setInterval, и при отсутствии сети
             *          создаем новый таск - новый setInterval) при первой же успешной отправке запроса, текущий таск должен чиститься.
             *      - для перестраховки, чтобы таск не запустил тот же запрос или паралельно следующий, нужно в свойствах очереди также хранить
             *          флаг processing, говорящий о том что в данный момент выполняются запросы в очереди. при успешном завершении запроса и
             *          переходе к следующему запросу, processing остается true. если автоматический таск при попытке запустить отправку запроса
             *          натыкается на состояние processing == true, значит что-то пошло не так и остался не удаленный таск, поэтому:
             *          не запускаем попытку отправки запроса (уже запущено), таск удаляем, новый таск создастся если очередной запрос опять
             *          сфэйлится с ошибкой отсутствия сети
             */ 
