для чего нужен requestHandler для использования внутри модуля, почему бы не вернуть из модуля response как есть, а доп функцией в сторе разделять ответ на 
success и failure:
- для sender'а модуль должен уметь отделять ошибки сети от "хороших" ошибок бизнес логики
- для receiver'а модуль должен уметь отделять действительно хороший ответ, который можно закэшировать, от "плохих" ответов или ошибок
- для кэширования нужно уметь извлекать данные из запроса, т.к. данные должны быть сереализуемыми
- requestHandler дает возможность на выходе из модуля получить готовый ответ - успешным был запрос или провалился, не придется наворачивать еще один
    обработчик вокруг модуля

почему api построено на колбэках а не на возвращаемом промисе:
- в receiver'е при стратегии cache-then-network, а в sender'е при ошибке сети, возникают ситуации, когда необходимо вернуть текущий результат, а также
    промис, которые зарезолвится потом - когда придут свежие данные по сети, или когда данные отправятся при появлении сети. Поэтому в этих случаях
    обработка ответов на стороне клиентского кода будет двух этапная. Это приводит к сложности кода обработчиков, а также к необходимости рефакторинга
    при смене стратегии кэширования.
- решение с колбэками позволяет один раз написать обработчик, который сможет обрабатывать разные варианты успешного ответа просто принимая аргументы 
    (данные пришли по сети, данные получены из кэша, данные успешно отправлены сразу или после восстановления сети). Аналогично с обработкой ошибок.
- решение с колбэками позволяет сделать дополнительные обработчики:
    - обработчик начала\окончания запроса
    - финальный обработчик
- если необходимо дождаться окончательного завершения работы sender'а или receiver'а в независимости от параметров, можно обернуть вызов sender\receiver
    в промис и использовать финальный обработчик, чтобы зарезолвить его

почему sender и receiver не принимают опциональные параметры: request, requestHandler, serializer и т.п. а задать их можно только в конструкторе сервиса:
- sender может автоматически запускать отправку запросов, которые были не отправлены и сохранены с прошлого запуска приложения. мы можем сохранить
    только сереализуемые данные, и не можем хранить специфические обработчики для некоторых отдельных запросов.
- в планах сделать возможность определения типа запроса (по ключу заданному явно или полученному через getCacheKey, или по дополнительному идентификатору)
    и под этот тип requestHandler'е сделать свой вариант обработки. Тогда идентификатор будет сохраняться вместе с запросом, и сервис сможет обработать
    запрос нужным образом

Что еще нужно сделать в модуле:

Что еще нужно сделать при интеграции в приложение:
- попробовать mobx со связкой через entityID
- придумать как хранить данные которые не отправляются на бэк, например: изменение статуса визита, геоточки
- попробовать сделать кастомную функцию для кэширования геоточек через оффлайн модуль
