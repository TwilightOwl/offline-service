для чего нужен requestHandler для использования внутри модуля, почему бы не вернуть из модуля response как есть, а доп функцией в сторе разделять ответ на 
success и failure:
- для sender'а модуль должен уметь отделять ошибки сети от "хороших" ошибок бизнес логики
- для receiver'а модуль должен уметь отделять действительно хороший ответ, который можно закэшировать, от "плохих" ответов или ошибок
- для кэширования нужно уметь извлекать данные из запроса, т.к. данные должны быть сереализуемыми
- requestHandler дает возможность на выходе из модуля получить готовый ответ - успешным был запрос или провалился, не придется наворачивать еще один
    обработчик вокруг модуля

почему api построено на колбэках а не на возвращаемом промисе:
- в receiver'е при стратегии cache-then-network, а в sender'е при ошибке сети, возникают ситуации, когда необходимо вернуть текущий результат, а также
    промис, которые зарезолвится потом - когда придут свежие данные по сети, или когда данные отправятся при появлении сети. Поэтому в этих случаях
    обработка ответов на стороне клиентского кода будет двух этапная. Это приводит к сложности кода обработчиков, а также к необходимости рефакторинга
    при смене стратегии кэширования.
- решение с колбэками позволяет один раз написать обработчик, который сможет обрабатывать разные варианты успешного ответа просто принимая аргументы 
    (данные пришли по сети, данные получены из кэша, данные успешно отправлены сразу или после восстановления сети). Аналогично с обработкой ошибок.
- решение с колбэками позволяет сделать дополнительные обработчики:
    - обработчик начала\окончания запроса
    - финальный обработчик
- если необходимо дождаться окончательного завершения работы sender'а или receiver'а в независимости от параметров, можно обернуть вызов sender\receiver
    в промис и использовать финальный обработчик, чтобы зарезолвить его

почему sender и receiver не принимают опциональные параметры: request, requestHandler, serializer и т.п. а задать их можно только в конструкторе сервиса:
- sender может автоматически запускать отправку запросов, которые были не отправлены и сохранены с прошлого запуска приложения. мы можем сохранить
    только сереализуемые данные, и не можем хранить специфические обработчики для некоторых отдельных запросов.
- в планах сделать возможность определения типа запроса (по ключу заданному явно или полученному через getCacheKey, или по дополнительному идентификатору)
    и под этот тип requestHandler'е сделать свой вариант обработки. Тогда идентификатор будет сохраняться вместе с запросом, и сервис сможет обработать
    запрос нужным образом

Что еще нужно сделать в модуле:

- сейчас, после рестарта приложения, нет возможности повешать обработчики на отправку ранее не отправленных запросов, т.к. обработчики нельзя сериализовать
    - в нормальном режиме обработчики работают в проинициализированном сторе
    - после перезапуска есть некотрые варианты:
        - стор должен быть проинициализирован чтобы иметь возможность запускать обработчики реагируя на какой-то глобальный эммитер
        - делать обработчики сразу отделенными от стора, но тогда нет доступа к внутренним данным стора
        - дублировать обработчики в сторе и в глобальном модуле отслеживания сендеров
        - вынести обработчики отдельно как чистые функции, сделав зависимыми только от входных параметров, но использовать их и в сторе
            и в глобальном модуле вызывая с разными параметрами
- сейчас future-response объекты достаточно тривиально реализованы, исходя из требований первого приложения где модуль начал использоваться. Но нужно 
    придумать более гибкую систему работы с этими сущностями и пересмотреть саму их структуру

Что еще нужно сделать при интеграции в приложение:
- попробовать mobx со связкой через entityID
- придумать как хранить данные которые не отправляются на бэк, например: изменение статуса визита, геоточки
    - не имеет отношения к модулю
- попробовать сделать кастомную функцию для кэширования геоточек через оффлайн модуль
    - проблематично это сделать не в самом модуле, а подружить его с httpservice'ом